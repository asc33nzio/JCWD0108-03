{"ast":null,"code":"'use client'; // src/use-tabs.ts\n\nimport { useClickable } from \"@chakra-ui/clickable\";\nimport { createDescendantContext } from \"@chakra-ui/descendant\";\nimport { createContext } from \"@chakra-ui/react-context\";\nimport { useSafeLayoutEffect } from \"@chakra-ui/react-use-safe-layout-effect\";\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\";\nimport { getValidChildren } from \"@chakra-ui/react-children-utils\";\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\";\nimport { lazyDisclosure } from \"@chakra-ui/lazy-utils\";\nimport { callAllHandlers } from \"@chakra-ui/shared-utils\";\nimport { useCallback, useEffect, useRef, useState, useId, createElement } from \"react\";\nvar [TabsDescendantsProvider, useTabsDescendantsContext, useTabsDescendants, useTabsDescendant] = createDescendantContext();\n\nfunction useTabs(props) {\n  var _a;\n\n  const {\n    defaultIndex,\n    onChange,\n    index,\n    isManual,\n    isLazy,\n    lazyBehavior = \"unmount\",\n    orientation = \"horizontal\",\n    direction = \"ltr\",\n    ...htmlProps\n  } = props;\n  const [focusedIndex, setFocusedIndex] = useState(defaultIndex != null ? defaultIndex : 0);\n  const [selectedIndex, setSelectedIndex] = useControllableState({\n    defaultValue: defaultIndex != null ? defaultIndex : 0,\n    value: index,\n    onChange\n  });\n  useEffect(() => {\n    if (index != null) {\n      setFocusedIndex(index);\n    }\n  }, [index]);\n  const descendants = useTabsDescendants();\n  const uuid = useId();\n  const uid = (_a = props.id) != null ? _a : uuid;\n  const id = `tabs-${uid}`;\n  return {\n    id,\n    selectedIndex,\n    focusedIndex,\n    setSelectedIndex,\n    setFocusedIndex,\n    isManual,\n    isLazy,\n    lazyBehavior,\n    orientation,\n    descendants,\n    direction,\n    htmlProps\n  };\n}\n\nvar [TabsProvider, useTabsContext] = createContext({\n  name: \"TabsContext\",\n  errorMessage: \"useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />\"\n});\n\nfunction useTabList(props) {\n  const {\n    focusedIndex,\n    orientation,\n    direction\n  } = useTabsContext();\n  const descendants = useTabsDescendantsContext();\n  const onKeyDown = useCallback(event => {\n    const nextTab = () => {\n      var _a;\n\n      const next = descendants.nextEnabled(focusedIndex);\n      if (next) (_a = next.node) == null ? void 0 : _a.focus();\n    };\n\n    const prevTab = () => {\n      var _a;\n\n      const prev = descendants.prevEnabled(focusedIndex);\n      if (prev) (_a = prev.node) == null ? void 0 : _a.focus();\n    };\n\n    const firstTab = () => {\n      var _a;\n\n      const first = descendants.firstEnabled();\n      if (first) (_a = first.node) == null ? void 0 : _a.focus();\n    };\n\n    const lastTab = () => {\n      var _a;\n\n      const last = descendants.lastEnabled();\n      if (last) (_a = last.node) == null ? void 0 : _a.focus();\n    };\n\n    const isHorizontal = orientation === \"horizontal\";\n    const isVertical = orientation === \"vertical\";\n    const eventKey = event.key;\n    const ArrowStart = direction === \"ltr\" ? \"ArrowLeft\" : \"ArrowRight\";\n    const ArrowEnd = direction === \"ltr\" ? \"ArrowRight\" : \"ArrowLeft\";\n    const keyMap = {\n      [ArrowStart]: () => isHorizontal && prevTab(),\n      [ArrowEnd]: () => isHorizontal && nextTab(),\n      ArrowDown: () => isVertical && nextTab(),\n      ArrowUp: () => isVertical && prevTab(),\n      Home: firstTab,\n      End: lastTab\n    };\n    const action = keyMap[eventKey];\n\n    if (action) {\n      event.preventDefault();\n      action(event);\n    }\n  }, [descendants, focusedIndex, orientation, direction]);\n  return { ...props,\n    role: \"tablist\",\n    \"aria-orientation\": orientation,\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)\n  };\n}\n\nfunction useTab(props) {\n  const {\n    isDisabled = false,\n    isFocusable = false,\n    ...htmlProps\n  } = props;\n  const {\n    setSelectedIndex,\n    isManual,\n    id,\n    setFocusedIndex,\n    selectedIndex\n  } = useTabsContext();\n  const {\n    index,\n    register\n  } = useTabsDescendant({\n    disabled: isDisabled && !isFocusable\n  });\n  const isSelected = index === selectedIndex;\n\n  const onClick = () => {\n    setSelectedIndex(index);\n  };\n\n  const onFocus = () => {\n    setFocusedIndex(index);\n    const isDisabledButFocusable = isDisabled && isFocusable;\n    const shouldSelect = !isManual && !isDisabledButFocusable;\n\n    if (shouldSelect) {\n      setSelectedIndex(index);\n    }\n  };\n\n  const clickableProps = useClickable({ ...htmlProps,\n    ref: mergeRefs(register, props.ref),\n    isDisabled,\n    isFocusable,\n    onClick: callAllHandlers(props.onClick, onClick)\n  });\n  const type = \"button\";\n  return { ...clickableProps,\n    id: makeTabId(id, index),\n    role: \"tab\",\n    tabIndex: isSelected ? 0 : -1,\n    type,\n    \"aria-selected\": isSelected,\n    \"aria-controls\": makeTabPanelId(id, index),\n    onFocus: isDisabled ? void 0 : callAllHandlers(props.onFocus, onFocus)\n  };\n}\n\nvar [TabPanelProvider, useTabPanelContext] = createContext({});\n\nfunction useTabPanels(props) {\n  const context = useTabsContext();\n  const {\n    id,\n    selectedIndex\n  } = context;\n  const validChildren = getValidChildren(props.children);\n  const children = validChildren.map((child, index) => createElement(TabPanelProvider, {\n    key: index,\n    value: {\n      isSelected: index === selectedIndex,\n      id: makeTabPanelId(id, index),\n      tabId: makeTabId(id, index),\n      selectedIndex\n    }\n  }, child));\n  return { ...props,\n    children\n  };\n}\n\nfunction useTabPanel(props) {\n  const {\n    children,\n    ...htmlProps\n  } = props;\n  const {\n    isLazy,\n    lazyBehavior\n  } = useTabsContext();\n  const {\n    isSelected,\n    id,\n    tabId\n  } = useTabPanelContext();\n  const hasBeenSelected = useRef(false);\n\n  if (isSelected) {\n    hasBeenSelected.current = true;\n  }\n\n  const shouldRenderChildren = lazyDisclosure({\n    wasSelected: hasBeenSelected.current,\n    isSelected,\n    enabled: isLazy,\n    mode: lazyBehavior\n  });\n  return {\n    // Puts the tabpanel in the page `Tab` sequence.\n    tabIndex: 0,\n    ...htmlProps,\n    children: shouldRenderChildren ? children : null,\n    role: \"tabpanel\",\n    \"aria-labelledby\": tabId,\n    hidden: !isSelected,\n    id\n  };\n}\n\nfunction useTabIndicator() {\n  const context = useTabsContext();\n  const descendants = useTabsDescendantsContext();\n  const {\n    selectedIndex,\n    orientation\n  } = context;\n  const isHorizontal = orientation === \"horizontal\";\n  const isVertical = orientation === \"vertical\";\n  const [rect, setRect] = useState(() => {\n    if (isHorizontal) return {\n      left: 0,\n      width: 0\n    };\n    if (isVertical) return {\n      top: 0,\n      height: 0\n    };\n    return void 0;\n  });\n  const [hasMeasured, setHasMeasured] = useState(false);\n  useSafeLayoutEffect(() => {\n    if (selectedIndex == null) return;\n    const tab = descendants.item(selectedIndex);\n    if (tab == null) return;\n\n    if (isHorizontal) {\n      setRect({\n        left: tab.node.offsetLeft,\n        width: tab.node.offsetWidth\n      });\n    }\n\n    if (isVertical) {\n      setRect({\n        top: tab.node.offsetTop,\n        height: tab.node.offsetHeight\n      });\n    }\n\n    const id = requestAnimationFrame(() => {\n      setHasMeasured(true);\n    });\n    return () => {\n      if (id) {\n        cancelAnimationFrame(id);\n      }\n    };\n  }, [selectedIndex, isHorizontal, isVertical, descendants]);\n  return {\n    position: \"absolute\",\n    transitionProperty: \"left, right, top, bottom, height, width\",\n    transitionDuration: hasMeasured ? \"200ms\" : \"0ms\",\n    transitionTimingFunction: \"cubic-bezier(0, 0, 0.2, 1)\",\n    ...rect\n  };\n}\n\nfunction makeTabId(id, index) {\n  return `${id}--tab-${index}`;\n}\n\nfunction makeTabPanelId(id, index) {\n  return `${id}--tabpanel-${index}`;\n}\n\nexport { TabsDescendantsProvider, useTabsDescendantsContext, useTabsDescendants, useTabsDescendant, useTabs, TabsProvider, useTabsContext, useTabList, useTab, useTabPanels, useTabPanel, useTabIndicator };","map":{"version":3,"mappings":"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","names":["useClickable","createDescendantContext","createContext","useSafeLayoutEffect","useControllableState","getValidChildren","mergeRefs","lazyDisclosure","callAllHandlers","useCallback","useEffect","useRef","useState","useId","createElement","TabsDescendantsProvider","useTabsDescendantsContext","useTabsDescendants","useTabsDescendant","useTabs","props","defaultIndex","onChange","index","isManual","isLazy","lazyBehavior","orientation","direction","htmlProps","focusedIndex","setFocusedIndex","selectedIndex","setSelectedIndex","defaultValue","value","descendants","uuid","uid","_a","id","TabsProvider","useTabsContext","name","errorMessage","useTabList","onKeyDown","event","nextTab","next","nextEnabled","node","focus","prevTab","prev","prevEnabled","firstTab","first","firstEnabled","lastTab","last","lastEnabled","isHorizontal","isVertical","eventKey","key","ArrowStart","ArrowEnd","keyMap","ArrowDown","ArrowUp","Home","End","action","preventDefault","role","useTab","isDisabled","isFocusable","register","disabled","isSelected","onClick","onFocus","isDisabledButFocusable","shouldSelect","clickableProps","ref","type","makeTabId","tabIndex","makeTabPanelId","TabPanelProvider","useTabPanelContext","useTabPanels","context","validChildren","children","map","child","tabId","useTabPanel","hasBeenSelected","current","shouldRenderChildren","wasSelected","enabled","mode","hidden","useTabIndicator","rect","setRect","left","width","top","height","hasMeasured","setHasMeasured","tab","item","offsetLeft","offsetWidth","offsetTop","offsetHeight","requestAnimationFrame","cancelAnimationFrame","position","transitionProperty","transitionDuration","transitionTimingFunction"],"sources":["C:\\Purwadhika\\JCWD Bandung\\4. REAL PROJECT\\JCWD0108-03\\node_modules\\@chakra-ui\\tabs\\src\\use-tabs.ts"],"sourcesContent":["import { useClickable, UseClickableProps } from \"@chakra-ui/clickable\"\nimport { createDescendantContext } from \"@chakra-ui/descendant\"\nimport { createContext } from \"@chakra-ui/react-context\"\nimport { useSafeLayoutEffect } from \"@chakra-ui/react-use-safe-layout-effect\"\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\"\nimport { getValidChildren } from \"@chakra-ui/react-children-utils\"\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\"\nimport { lazyDisclosure, LazyMode } from \"@chakra-ui/lazy-utils\"\nimport { callAllHandlers } from \"@chakra-ui/shared-utils\"\nimport {\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n  useId,\n  createElement,\n} from \"react\"\n\n/* -------------------------------------------------------------------------------------------------\n * Create context to track descendants and their indices\n * -----------------------------------------------------------------------------------------------*/\n\nexport const [\n  TabsDescendantsProvider,\n  useTabsDescendantsContext,\n  useTabsDescendants,\n  useTabsDescendant,\n] = createDescendantContext<HTMLButtonElement>()\n\n/* -------------------------------------------------------------------------------------------------\n * useTabs - The root react hook that manages all tab items\n * -----------------------------------------------------------------------------------------------*/\n\nexport interface UseTabsProps {\n  /**\n   * The orientation of the tab list.\n   * @default \"horizontal\"\n   */\n  orientation?: \"vertical\" | \"horizontal\"\n  /**\n   * If `true`, the tabs will be manually activated and\n   * display its panel by pressing Space or Enter.\n   *\n   * If `false`, the tabs will be automatically activated\n   * and their panel is displayed when they receive focus.\n   *\n   * @default false\n   */\n  isManual?: boolean\n  /**\n   * Callback when the index (controlled or un-controlled) changes.\n   */\n  onChange?: (index: number) => void\n  /**\n   * The index of the selected tab (in controlled mode)\n   */\n  index?: number\n  /**\n   * The initial index of the selected tab (in uncontrolled mode)\n   */\n  defaultIndex?: number\n  /**\n   * The id of the tab\n   */\n  id?: string\n  /**\n   * Performance ðŸš€:\n   * If `true`, rendering of the tab panel's will be deferred until it is selected.\n   * @default false\n   */\n  isLazy?: boolean\n  /**\n   * Performance ðŸš€:\n   * The lazy behavior of tab panels' content when not active.\n   * Only works when `isLazy={true}`\n   *\n   * - \"unmount\": The content of inactive tab panels are always unmounted.\n   * - \"keepMounted\": The content of inactive tab panels is initially unmounted,\n   * but stays mounted when selected.\n   *\n   * @default \"unmount\"\n   */\n  lazyBehavior?: LazyMode\n  /**\n   * The writing mode direction.\n   *\n   * - When in RTL, the left and right navigation is flipped\n   * @default \"ltr\"\n   */\n  direction?: \"rtl\" | \"ltr\"\n}\n\n/**\n * Tabs hook that provides all the states, and accessibility\n * helpers to keep all things working properly.\n *\n * Its returned object will be passed unto a Context Provider\n * so all child components can read from it.\n * There is no document link yet\n * @see Docs https://chakra-ui.com/docs/components/useTabs\n * @see WAI-ARIA https://www.w3.org/WAI/ARIA/apg/patterns/tabpanel/\n */\nexport function useTabs(props: UseTabsProps) {\n  const {\n    defaultIndex,\n    onChange,\n    index,\n    isManual,\n    isLazy,\n    lazyBehavior = \"unmount\",\n    orientation = \"horizontal\",\n    direction = \"ltr\",\n    ...htmlProps\n  } = props\n\n  /**\n   * We use this to keep track of the index of the focused tab.\n   *\n   * Tabs can be automatically activated, this means selection follows focus.\n   * When we navigate with the arrow keys, we move focus and selection to next/prev tab\n   *\n   * Tabs can also be manually activated, this means selection does not follow focus.\n   * When we navigate with the arrow keys, we only move focus NOT selection. The user\n   * will need not manually activate the tab using `Enter` or `Space`.\n   *\n   * This is why we need to keep track of the `focusedIndex` and `selectedIndex`\n   */\n  const [focusedIndex, setFocusedIndex] = useState(defaultIndex ?? 0)\n\n  const [selectedIndex, setSelectedIndex] = useControllableState({\n    defaultValue: defaultIndex ?? 0,\n    value: index,\n    onChange,\n  })\n\n  /**\n   * Sync focused `index` with controlled `selectedIndex` (which is the `props.index`)\n   */\n  useEffect(() => {\n    if (index != null) {\n      setFocusedIndex(index)\n    }\n  }, [index])\n\n  /**\n   * Think of `useDescendants` as a register for the tab nodes.\n   */\n  const descendants = useTabsDescendants()\n\n  /**\n   * Generate a unique id or use user-provided id for the tabs widget\n   */\n  const uuid = useId()\n  const uid = props.id ?? uuid\n  const id = `tabs-${uid}`\n\n  return {\n    id,\n    selectedIndex,\n    focusedIndex,\n    setSelectedIndex,\n    setFocusedIndex,\n    isManual,\n    isLazy,\n    lazyBehavior,\n    orientation,\n    descendants,\n    direction,\n    htmlProps,\n  }\n}\n\nexport type UseTabsReturn = Omit<\n  ReturnType<typeof useTabs>,\n  \"htmlProps\" | \"descendants\"\n>\n\nexport const [TabsProvider, useTabsContext] = createContext<UseTabsReturn>({\n  name: \"TabsContext\",\n  errorMessage:\n    \"useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />\",\n})\n\nexport interface UseTabListProps {\n  children?: React.ReactNode\n  onKeyDown?: React.KeyboardEventHandler\n  ref?: React.Ref<any>\n}\n\n/**\n * Tabs hook to manage multiple tab buttons,\n * and ensures only one tab is selected per time.\n *\n * @param props props object for the tablist\n */\nexport function useTabList<P extends UseTabListProps>(props: P) {\n  const { focusedIndex, orientation, direction } = useTabsContext()\n\n  const descendants = useTabsDescendantsContext()\n\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const nextTab = () => {\n        const next = descendants.nextEnabled(focusedIndex)\n        if (next) next.node?.focus()\n      }\n      const prevTab = () => {\n        const prev = descendants.prevEnabled(focusedIndex)\n        if (prev) prev.node?.focus()\n      }\n      const firstTab = () => {\n        const first = descendants.firstEnabled()\n        if (first) first.node?.focus()\n      }\n      const lastTab = () => {\n        const last = descendants.lastEnabled()\n        if (last) last.node?.focus()\n      }\n\n      const isHorizontal = orientation === \"horizontal\"\n      const isVertical = orientation === \"vertical\"\n\n      const eventKey = event.key\n\n      const ArrowStart = direction === \"ltr\" ? \"ArrowLeft\" : \"ArrowRight\"\n      const ArrowEnd = direction === \"ltr\" ? \"ArrowRight\" : \"ArrowLeft\"\n\n      const keyMap: Record<string, React.KeyboardEventHandler> = {\n        [ArrowStart]: () => isHorizontal && prevTab(),\n        [ArrowEnd]: () => isHorizontal && nextTab(),\n        ArrowDown: () => isVertical && nextTab(),\n        ArrowUp: () => isVertical && prevTab(),\n        Home: firstTab,\n        End: lastTab,\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        action(event)\n      }\n    },\n    [descendants, focusedIndex, orientation, direction],\n  )\n\n  return {\n    ...props,\n    role: \"tablist\",\n    \"aria-orientation\": orientation,\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n  }\n}\n\nexport type UseTabListReturn = ReturnType<typeof useTabList>\n\nexport interface UseTabOptions {\n  /**\n   * If `true`, the `Tab` won't be toggleable\n   * @default false\n   */\n  isDisabled?: boolean\n  /**\n   * If `true` and `isDisabled`, the `Tab` will be focusable but not interactive.\n   * @default false\n   */\n  isFocusable?: boolean\n}\n\nexport interface UseTabProps\n  extends Omit<UseClickableProps, \"color\">,\n    UseTabOptions {}\n\n/**\n * Tabs hook to manage each tab button.\n *\n * A tab can be disabled and focusable, or both,\n * hence the use of `useClickable` to handle this scenario\n */\nexport function useTab<P extends UseTabProps>(props: P) {\n  const { isDisabled = false, isFocusable = false, ...htmlProps } = props\n\n  const { setSelectedIndex, isManual, id, setFocusedIndex, selectedIndex } =\n    useTabsContext()\n\n  const { index, register } = useTabsDescendant({\n    disabled: isDisabled && !isFocusable,\n  })\n\n  const isSelected = index === selectedIndex\n\n  const onClick = () => {\n    setSelectedIndex(index)\n  }\n\n  const onFocus = () => {\n    setFocusedIndex(index)\n    const isDisabledButFocusable = isDisabled && isFocusable\n    const shouldSelect = !isManual && !isDisabledButFocusable\n    if (shouldSelect) {\n      setSelectedIndex(index)\n    }\n  }\n\n  const clickableProps = useClickable({\n    ...htmlProps,\n    ref: mergeRefs(register, props.ref),\n    isDisabled,\n    isFocusable,\n    onClick: callAllHandlers(props.onClick, onClick),\n  })\n\n  const type: \"button\" | \"submit\" | \"reset\" = \"button\"\n\n  return {\n    ...clickableProps,\n    id: makeTabId(id, index),\n    role: \"tab\",\n    tabIndex: isSelected ? 0 : -1,\n    type,\n    \"aria-selected\": isSelected,\n    \"aria-controls\": makeTabPanelId(id, index),\n    onFocus: isDisabled ? undefined : callAllHandlers(props.onFocus, onFocus),\n  }\n}\n\nexport interface UseTabPanelsProps {\n  children?: React.ReactNode\n}\n\nconst [TabPanelProvider, useTabPanelContext] = createContext<{\n  isSelected: boolean\n  id: string\n  tabId: string\n  selectedIndex: number\n}>({})\n\n/**\n * Tabs hook for managing the visibility of multiple tab panels.\n *\n * Since only one panel can be show at a time, we use `cloneElement`\n * to inject `selected` panel to each TabPanel.\n *\n * It returns a cloned version of its children with\n * all functionality included.\n */\nexport function useTabPanels<P extends UseTabPanelsProps>(props: P) {\n  const context = useTabsContext()\n\n  const { id, selectedIndex } = context\n\n  const validChildren = getValidChildren(props.children)\n\n  const children = validChildren.map((child, index) =>\n    createElement(\n      TabPanelProvider,\n      {\n        key: index,\n        value: {\n          isSelected: index === selectedIndex,\n          id: makeTabPanelId(id, index),\n          tabId: makeTabId(id, index),\n          selectedIndex,\n        },\n      },\n      child,\n    ),\n  )\n\n  return { ...props, children }\n}\n\n/**\n * Tabs hook for managing the visible/hidden states\n * of the tab panel.\n *\n * @param props props object for the tab panel\n */\nexport function useTabPanel(props: Record<string, any>) {\n  const { children, ...htmlProps } = props\n  const { isLazy, lazyBehavior } = useTabsContext()\n  const { isSelected, id, tabId } = useTabPanelContext()\n\n  const hasBeenSelected = useRef(false)\n  if (isSelected) {\n    hasBeenSelected.current = true\n  }\n\n  const shouldRenderChildren = lazyDisclosure({\n    wasSelected: hasBeenSelected.current,\n    isSelected,\n    enabled: isLazy,\n    mode: lazyBehavior,\n  })\n\n  return {\n    // Puts the tabpanel in the page `Tab` sequence.\n    tabIndex: 0,\n    ...htmlProps,\n    children: shouldRenderChildren ? children : null,\n    role: \"tabpanel\",\n    \"aria-labelledby\": tabId,\n    hidden: !isSelected,\n    id,\n  }\n}\n\n/**\n * Tabs hook to show an animated indicators that\n * follows the active tab.\n *\n * The way we do it is by measuring the DOM Rect (or dimensions)\n * of the active tab, and return that as CSS style for\n * the indicator.\n */\nexport function useTabIndicator(): React.CSSProperties {\n  const context = useTabsContext()\n  const descendants = useTabsDescendantsContext()\n\n  const { selectedIndex, orientation } = context\n\n  const isHorizontal = orientation === \"horizontal\"\n  const isVertical = orientation === \"vertical\"\n\n  // Get the clientRect of the selected tab\n  const [rect, setRect] = useState(() => {\n    if (isHorizontal) return { left: 0, width: 0 }\n    if (isVertical) return { top: 0, height: 0 }\n    return undefined\n  })\n\n  const [hasMeasured, setHasMeasured] = useState(false)\n\n  // Update the selected tab rect when the selectedIndex changes\n  useSafeLayoutEffect(() => {\n    if (selectedIndex == null) return\n\n    const tab = descendants.item(selectedIndex)\n    if (tab == null) return\n\n    // Horizontal Tab: Calculate width and left distance\n    if (isHorizontal) {\n      setRect({ left: tab.node.offsetLeft, width: tab.node.offsetWidth })\n    }\n\n    // Vertical Tab: Calculate height and top distance\n    if (isVertical) {\n      setRect({ top: tab.node.offsetTop, height: tab.node.offsetHeight })\n    }\n\n    // Prevent unwanted transition from 0 to measured rect\n    // by setting the measured state in the next tick\n    const id = requestAnimationFrame(() => {\n      setHasMeasured(true)\n    })\n\n    return () => {\n      if (id) {\n        cancelAnimationFrame(id)\n      }\n    }\n  }, [selectedIndex, isHorizontal, isVertical, descendants])\n\n  return {\n    position: \"absolute\",\n    transitionProperty: \"left, right, top, bottom, height, width\",\n    transitionDuration: hasMeasured ? \"200ms\" : \"0ms\",\n    transitionTimingFunction: \"cubic-bezier(0, 0, 0.2, 1)\",\n    ...rect,\n  }\n}\n\nfunction makeTabId(id: string, index: number) {\n  return `${id}--tab-${index}`\n}\n\nfunction makeTabPanelId(id: string, index: number) {\n  return `${id}--tabpanel-${index}`\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { namedEdges, resolveEdge } from './edge.mjs';\nconst defaultOffset = [0, 0];\n\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n  let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n  let targetPoint = 0;\n  let containerPoint = 0;\n\n  if (typeof offset === \"number\") {\n    /**\n     * If we're provided offset: [0, 0.5, 1] then each number x should become\n     * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n     * and container etc.\n     */\n    offsetDefinition = [offset, offset];\n  } else if (typeof offset === \"string\") {\n    offset = offset.trim();\n\n    if (offset.includes(\" \")) {\n      offsetDefinition = offset.split(\" \");\n    } else {\n      /**\n       * If we're provided a definition like \"100px\" then we want to apply\n       * that only to the top of the target point, leaving the container at 0.\n       * Whereas a named offset like \"end\" should be applied to both.\n       */\n      offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n    }\n  }\n\n  targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n  containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n  return targetPoint - containerPoint;\n}\n\nexport { resolveOffset };","map":{"version":3,"names":["namedEdges","resolveEdge","defaultOffset","resolveOffset","offset","containerLength","targetLength","targetInset","offsetDefinition","Array","isArray","targetPoint","containerPoint","trim","includes","split"],"sources":["C:/Purwadhika/JCWD Bandung/4. REAL PROJECT/JCWD0108-03/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/offset.mjs"],"sourcesContent":["import { namedEdges, resolveEdge } from './edge.mjs';\n\nconst defaultOffset = [0, 0];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n    let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n    let targetPoint = 0;\n    let containerPoint = 0;\n    if (typeof offset === \"number\") {\n        /**\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */\n        offsetDefinition = [offset, offset];\n    }\n    else if (typeof offset === \"string\") {\n        offset = offset.trim();\n        if (offset.includes(\" \")) {\n            offsetDefinition = offset.split(\" \");\n        }\n        else {\n            /**\n             * If we're provided a definition like \"100px\" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like \"end\" should be applied to both.\n             */\n            offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n        }\n    }\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n    return targetPoint - containerPoint;\n}\n\nexport { resolveOffset };\n"],"mappings":"AAAA,SAASA,UAAT,EAAqBC,WAArB,QAAwC,YAAxC;AAEA,MAAMC,aAAa,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAtB;;AACA,SAASC,aAAT,CAAuBC,MAAvB,EAA+BC,eAA/B,EAAgDC,YAAhD,EAA8DC,WAA9D,EAA2E;EACvE,IAAIC,gBAAgB,GAAGC,KAAK,CAACC,OAAN,CAAcN,MAAd,IAAwBA,MAAxB,GAAiCF,aAAxD;EACA,IAAIS,WAAW,GAAG,CAAlB;EACA,IAAIC,cAAc,GAAG,CAArB;;EACA,IAAI,OAAOR,MAAP,KAAkB,QAAtB,EAAgC;IAC5B;AACR;AACA;AACA;AACA;IACQI,gBAAgB,GAAG,CAACJ,MAAD,EAASA,MAAT,CAAnB;EACH,CAPD,MAQK,IAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC;IACjCA,MAAM,GAAGA,MAAM,CAACS,IAAP,EAAT;;IACA,IAAIT,MAAM,CAACU,QAAP,CAAgB,GAAhB,CAAJ,EAA0B;MACtBN,gBAAgB,GAAGJ,MAAM,CAACW,KAAP,CAAa,GAAb,CAAnB;IACH,CAFD,MAGK;MACD;AACZ;AACA;AACA;AACA;MACYP,gBAAgB,GAAG,CAACJ,MAAD,EAASJ,UAAU,CAACI,MAAD,CAAV,GAAqBA,MAArB,GAA+B,GAAxC,CAAnB;IACH;EACJ;;EACDO,WAAW,GAAGV,WAAW,CAACO,gBAAgB,CAAC,CAAD,CAAjB,EAAsBF,YAAtB,EAAoCC,WAApC,CAAzB;EACAK,cAAc,GAAGX,WAAW,CAACO,gBAAgB,CAAC,CAAD,CAAjB,EAAsBH,eAAtB,CAA5B;EACA,OAAOM,WAAW,GAAGC,cAArB;AACH;;AAED,SAAST,aAAT"},"metadata":{},"sourceType":"module"}